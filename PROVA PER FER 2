import heapq

def SalesmanTrackBranchAndBound2(g, visits):
    def calculate_bound(current_path, unvisited):
        # Calculate a lower bound on the cost of any completion of the current_path
        current_cost = path_cost(current_path)
        min_edge_sum = 0
        for v in unvisited:
            min_edge = float('inf')
            for edge in v.Edges:
                if edge.Destination in unvisited:
                    min_edge = min(min_edge, edge.Length)
            min_edge_sum += min_edge
        return current_cost + min_edge_sum

    def path_cost(path):
        cost = 0
        for edge in path:
            cost += edge.Length
        return cost

    start_vertex = visits.Vertices[0]
    initial_path = []
    best_solution = (float('inf'), None)  # (cost, path)
    priority_queue = [(0, initial_path, [start_vertex])]

    while priority_queue:
        current_bound, current_path, visited_vertices = heapq.heappop(priority_queue)

        if len(visited_vertices) == len(visits.Vertices):
            total_cost = path_cost(current_path)
            if total_cost < best_solution[0]:
                best_solution = (total_cost, current_path)
            continue

        current_vertex = visited_vertices[-1]

        for edge in current_vertex.Edges:
            next_vertex = edge.Destination
            if next_vertex not in visited_vertices:
                new_path = current_path + [edge]
                new_visited = visited_vertices + [next_vertex]
                new_bound = calculate_bound(new_path, set(visits.Vertices) - set(new_visited))

                if new_bound < best_solution[0]:
                    heapq.heappush(priority_queue, (new_bound, new_path, new_visited))

    best_track = graph.Track(g)
    for edge in best_solution[1]:
        best_track.AddLast(edge)
    
    return best_track
